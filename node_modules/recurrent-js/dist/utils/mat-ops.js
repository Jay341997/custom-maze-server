"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const __1 = require("..");
const assertable_1 = require("./assertable");
class MatOps extends assertable_1.Assertable {
    static rowPluck(m, rowIndex) {
        __1.Mat.assert(rowIndex >= 0 && rowIndex < m.rows, '[class:MatOps] rowPluck: dimensions misaligned');
        const out = new __1.Mat(m.cols, 1);
        for (let i = 0; i < m.cols; i++) {
            out.w[i] = m.w[m.cols * rowIndex + i];
        }
        return out;
    }
    static getRowPluckBackprop(m, rowIndex, out) {
        return () => {
            for (let i = 0; i < m.cols; i++) {
                m.dw[m.cols * rowIndex + i] += out.dw[i];
            }
        };
    }
    static gauss(m, std) {
        __1.Mat.assert(m.w.length === std.w.length, '[class:MatOps] gauss: dimensions misaligned');
        const out = new __1.Mat(m.rows, m.cols);
        for (let i = 0; i < m.w.length; i++) {
            out.w[i] = __1.Utils.randn(m.w[i], std.w[i]);
        }
        return out;
    }
    static tanh(m) {
        const out = new __1.Mat(m.rows, m.cols);
        for (let i = 0; i < m.w.length; i++) {
            out.w[i] = Math.tanh(m.w[i]);
        }
        return out;
    }
    static getTanhBackprop(m, out) {
        return () => {
            for (let i = 0; i < m.w.length; i++) {
                const mwi = out.w[i];
                m.dw[i] += (1.0 - mwi * mwi) * out.dw[i];
            }
        };
    }
    static sig(m) {
        const out = new __1.Mat(m.rows, m.cols);
        for (let i = 0; i < m.w.length; i++) {
            out.w[i] = MatOps.sigmoid(m.w[i]);
        }
        return out;
    }
    static sigmoid(x) {
        return 1.0 / (1 + Math.exp(-x));
    }
    static getSigmoidBackprop(m, out) {
        return () => {
            for (let i = 0; i < m.w.length; i++) {
                const mwi = out.w[i];
                m.dw[i] += mwi * (1.0 - mwi) * out.dw[i];
            }
        };
    }
    static relu(m) {
        const out = new __1.Mat(m.rows, m.cols);
        for (let i = 0; i < m.w.length; i++) {
            out.w[i] = Math.max(0, m.w[i]);
        }
        return out;
    }
    static getReluBackprop(m, out) {
        return () => {
            for (let i = 0; i < m.w.length; i++) {
                m.dw[i] += m.w[i] > 0 ? out.dw[i] : 0.0;
            }
        };
    }
    static add(m1, m2) {
        __1.Mat.assert(m1.w.length === m2.w.length && m1.rows === m2.rows, '[class:MatOps] add: dimensions misaligned');
        const out = new __1.Mat(m1.rows, m1.cols);
        for (let i = 0; i < m1.w.length; i++) {
            out.w[i] = m1.w[i] + m2.w[i];
        }
        return out;
    }
    static getAddBackprop(m1, m2, out) {
        return () => {
            for (let i = 0; i < m1.w.length; i++) {
                m1.dw[i] += out.dw[i];
                m2.dw[i] += out.dw[i];
            }
        };
    }
    static mul(m1, m2) {
        __1.Mat.assert(m1.cols === m2.rows, '[class:MatOps] mul: dimensions misaligned');
        const out = new __1.Mat(m1.rows, m2.cols);
        for (let row = 0; row < m1.rows; row++) {
            for (let col = 0; col < m2.cols; col++) {
                let dot = 0.0;
                for (let k = 0; k < m1.cols; k++) {
                    dot += m1.w[m1.cols * row + k] * m2.w[m2.cols * k + col];
                }
                out.w[m2.cols * row + col] = dot;
            }
        }
        return out;
    }
    static getMulBackprop(m1, m2, out) {
        return () => {
            for (let i = 0; i < m1.rows; i++) {
                for (let j = 0; j < m2.cols; j++) {
                    for (let k = 0; k < m1.cols; k++) {
                        const b = out.dw[m2.cols * i + j];
                        m1.dw[m1.cols * i + k] += m2.w[m2.cols * k + j] * b;
                        m2.dw[m2.cols * k + j] += m1.w[m1.cols * i + k] * b;
                    }
                }
            }
        };
    }
    static dot(m1, m2) {
        __1.Mat.assert(m1.w.length === m2.w.length && m1.rows === m2.rows, '[class:MatOps] dot: dimensions misaligned');
        const out = new __1.Mat(1, 1);
        let dot = 0.0;
        for (let i = 0; i < m1.w.length; i++) {
            dot += m1.w[i] * m2.w[i];
        }
        out.w[0] = dot;
        return out;
    }
    static getDotBackprop(m1, m2, out) {
        return () => {
            for (let i = 0; i < m1.w.length; i++) {
                m1.dw[i] += m2.w[i] * out.dw[0];
                m2.dw[i] += m1.w[i] * out.dw[0];
            }
        };
    }
    static eltmul(m1, m2) {
        __1.Mat.assert(m1.w.length === m2.w.length && m1.rows === m2.rows, '[class:MatOps] eltmul: dimensions misaligned');
        const out = new __1.Mat(m1.rows, m1.cols);
        for (let i = 0; i < m1.w.length; i++) {
            out.w[i] = m1.w[i] * m2.w[i];
        }
        return out;
    }
    static getEltmulBackprop(m1, m2, out) {
        return () => {
            for (let i = 0; i < m1.w.length; i++) {
                m1.dw[i] += m2.w[i] * out.dw[i];
                m2.dw[i] += m1.w[i] * out.dw[i];
            }
        };
    }
}
exports.MatOps = MatOps;
//# sourceMappingURL=mat-ops.js.map