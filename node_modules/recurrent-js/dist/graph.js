"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const mat_ops_1 = require("./utils/mat-ops");
class Graph {
    constructor() {
        this.needsBackpropagation = false;
        this.backpropagationStack = new Array();
    }
    memorizeOperationSequence(isMemorizing = false) {
        this.needsBackpropagation = isMemorizing;
    }
    isMemorizingSequence() {
        return this.needsBackpropagation;
    }
    forgetCurrentSequence() {
        this.backpropagationStack.length = 0;
    }
    backward() {
        for (let i = this.backpropagationStack.length - 1; i >= 0; i--) {
            this.backpropagationStack[i]();
        }
    }
    rowPluck(m, rowIndex) {
        const out = mat_ops_1.MatOps.rowPluck(m, rowIndex);
        this.addRowPluckToBackpropagationStack(m, rowIndex, out);
        return out;
    }
    addRowPluckToBackpropagationStack(m, rowIndex, out) {
        if (this.needsBackpropagation) {
            const backward = mat_ops_1.MatOps.getRowPluckBackprop(m, rowIndex, out);
            this.backpropagationStack.push(backward);
        }
    }
    gauss(m, std) {
        const out = mat_ops_1.MatOps.gauss(m, std);
        return out;
    }
    tanh(m) {
        const out = mat_ops_1.MatOps.tanh(m);
        this.addTanhToBackpropagationStack(m, out);
        return out;
    }
    addTanhToBackpropagationStack(m, out) {
        if (this.needsBackpropagation) {
            const backward = mat_ops_1.MatOps.getTanhBackprop(m, out);
            this.backpropagationStack.push(backward);
        }
    }
    sig(m) {
        const out = mat_ops_1.MatOps.sig(m);
        this.addSigmoidToBackpropagationStack(m, out);
        return out;
    }
    addSigmoidToBackpropagationStack(m, out) {
        if (this.needsBackpropagation) {
            const backward = mat_ops_1.MatOps.getSigmoidBackprop(m, out);
            this.backpropagationStack.push(backward);
        }
    }
    relu(m) {
        const out = mat_ops_1.MatOps.relu(m);
        this.addReluToBackpropagationStack(m, out);
        return out;
    }
    addReluToBackpropagationStack(m, out) {
        if (this.needsBackpropagation) {
            const backward = mat_ops_1.MatOps.getReluBackprop(m, out);
            this.backpropagationStack.push(backward);
        }
    }
    add(m1, m2) {
        const out = mat_ops_1.MatOps.add(m1, m2);
        this.addAdditionToBackpropagationStack(m1, m2, out);
        return out;
    }
    addAdditionToBackpropagationStack(m1, m2, out) {
        if (this.needsBackpropagation) {
            const backward = mat_ops_1.MatOps.getAddBackprop(m1, m2, out);
            this.backpropagationStack.push(backward);
        }
    }
    mul(m1, m2) {
        const out = mat_ops_1.MatOps.mul(m1, m2);
        this.addMultiplyToBackpropagationStack(m1, m2, out);
        return out;
    }
    addMultiplyToBackpropagationStack(m1, m2, out) {
        if (this.needsBackpropagation) {
            const backward = mat_ops_1.MatOps.getMulBackprop(m1, m2, out);
            this.backpropagationStack.push(backward);
        }
    }
    dot(m1, m2) {
        const out = mat_ops_1.MatOps.dot(m1, m2);
        this.addDotToBackpropagationStack(m1, m2, out);
        return out;
    }
    addDotToBackpropagationStack(m1, m2, out) {
        if (this.needsBackpropagation) {
            const backward = mat_ops_1.MatOps.getDotBackprop(m1, m2, out);
            this.backpropagationStack.push(backward);
        }
    }
    eltmul(m1, m2) {
        const out = mat_ops_1.MatOps.eltmul(m1, m2);
        this.addEltmulToBackpropagationStack(m1, m2, out);
        return out;
    }
    addEltmulToBackpropagationStack(m1, m2, out) {
        if (this.needsBackpropagation) {
            const backward = mat_ops_1.MatOps.getEltmulBackprop(m1, m2, out);
            this.backpropagationStack.push(backward);
        }
    }
}
exports.Graph = Graph;
//# sourceMappingURL=graph.js.map