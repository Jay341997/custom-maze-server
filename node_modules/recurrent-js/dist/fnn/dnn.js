"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const __1 = require("./..");
const fnn_model_1 = require("./fnn-model");
class DNN extends fnn_model_1.FNNModel {
    constructor(opt) {
        super(opt);
    }
    specificForwardpass(state) {
        const activations = this.computeHiddenActivations(state);
        return activations;
    }
    computeHiddenActivations(state) {
        const hiddenActivations = new Array();
        for (let d = 0; d < this.architecture.hiddenUnits.length; d++) {
            const inputVector = d === 0 ? state : hiddenActivations[d - 1];
            const weightedInput = this.graph.mul(this.model.hidden.Wh[d], inputVector);
            const biasedWeightedInput = this.graph.add(weightedInput, this.model.hidden.bh[d]);
            const activation = this.graph.tanh(biasedWeightedInput);
            hiddenActivations.push(activation);
        }
        return hiddenActivations;
    }
    static toJSON(dnn) {
        const json = { hidden: { Wh: [], bh: [] }, decoder: { Wh: null, b: null } };
        for (let i = 0; i < dnn.model.hidden.Wh.length; i++) {
            json.hidden.Wh[i] = __1.Mat.toJSON(dnn.model.hidden.Wh[i]);
            json.hidden.bh[i] = __1.Mat.toJSON(dnn.model.hidden.bh[i]);
        }
        json.decoder.Wh = __1.Mat.toJSON(dnn.model.decoder.Wh);
        json.decoder.b = __1.Mat.toJSON(dnn.model.decoder.b);
        return json;
    }
    static fromJSON(json) {
        return new DNN(json);
    }
}
exports.DNN = DNN;
//# sourceMappingURL=dnn.js.map