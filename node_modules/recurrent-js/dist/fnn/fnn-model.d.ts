import { Graph, Mat, NetOpts } from './..';
import { ANN } from './ann';
import { Assertable } from './../utils/assertable';
export declare abstract class FNNModel extends Assertable implements ANN {
    protected architecture: {
        inputSize: number;
        hiddenUnits: Array<number>;
        outputSize: number;
    };
    protected training: {
        alpha: number;
        lossClamp: number;
        loss: number;
    };
    model: {
        hidden: {
            Wh: Array<Mat>;
            bh: Array<Mat>;
        };
        decoder: {
            Wh: Mat;
            b: Mat;
        };
    };
    protected graph: Graph;
    protected previousOutput: Mat;
    constructor(opt: {
        hidden: {
            Wh: any;
            bh: any;
        };
        decoder: {
            Wh: Mat;
            b: Mat;
        };
    });
    constructor(opt: NetOpts);
    private initializeNeuralNetworkFromGivenOptions;
    protected static isFromJSON(opt: any): boolean;
    protected initializeModelFromJSONObject(opt: {
        hidden: {
            Wh: any;
            bh: any;
        };
        decoder: {
            Wh: any;
            b: any;
        };
    }): void;
    protected initializeHiddenLayerFromJSON(opt: {
        hidden: {
            Wh: Array<Mat>;
            bh: Array<Mat>;
        };
        decoder: {
            Wh: Mat;
            b: Mat;
        };
    }): void;
    protected static isFreshInstanceCall(opt: any): boolean;
    protected initializeModelAsFreshInstance(opt: NetOpts): void;
    protected determineArchitectureProperties(opt: NetOpts): {
        inputSize: number;
        hiddenUnits: Array<number>;
        outputSize: number;
    };
    protected determineTrainingProperties(opt: NetOpts): {
        alpha: number;
        lossClamp: number;
        loss: number;
    };
    protected initializeFreshNetworkModel(): {
        hidden: {
            Wh: Array<Mat>;
            bh: Array<Mat>;
        };
        decoder: {
            Wh: Mat;
            b: Mat;
        };
    };
    protected initializeHiddenLayer(mu: number, std: number): void;
    private getPrecedingLayerSize;
    protected initializeDecoder(mu: number, std: number): void;
    setTrainability(isTrainable: boolean): void;
    backward(expectedOutput: Array<number> | Float64Array, alpha?: number): void;
    private backwardGraph;
    private resetGraph;
    private propagateLossIntoDecoderLayer;
    private clipLoss;
    protected updateWeights(alpha?: number): void;
    protected updateHiddenLayer(alpha: number): void;
    protected updateDecoderLayer(alpha: number): void;
    forward(input: Array<number> | Float64Array): Array<number> | Float64Array;
    private transformArrayToMat;
    private transformMatToArray;
    protected abstract specificForwardpass(state: Mat): Array<Mat>;
    protected computeOutput(hiddenUnitActivations: Array<Mat>): Mat;
    getSquaredLossFor(input: number[] | Float64Array, expectedOutput: number[] | Float64Array): number;
    private calculateLossSumByForwardPass;
    private static has;
}
