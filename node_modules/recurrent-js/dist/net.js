"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _1 = require(".");
class Net {
    constructor(opt) {
        if (this.isFromJSON(opt)) {
            this.initializeFromJSONObject(opt);
        }
        else if (this.isFreshInstanceCall(opt)) {
            this.initializeAsFreshInstance(opt);
        }
        else {
            this.initializeAsFreshInstance({ architecture: { inputSize: 1, hiddenUnits: [1], outputSize: 1 } });
        }
    }
    isFromJSON(opt) {
        return Net.has(opt, ['W1', 'b1', 'W2', 'b2']);
    }
    isFreshInstanceCall(opt) {
        return Net.has(opt, ['architecture']) && Net.has(opt.architecture, ['inputSize', 'hiddenUnits', 'outputSize']);
    }
    initializeFromJSONObject(opt) {
        this.W1 = _1.Mat.fromJSON(opt['W1']);
        this.b1 = _1.Mat.fromJSON(opt['b1']);
        this.W2 = _1.Mat.fromJSON(opt['W2']);
        this.b2 = _1.Mat.fromJSON(opt['b2']);
    }
    initializeAsFreshInstance(opt) {
        let mu = 0;
        let std = 0.01;
        if (Net.has(opt, ['other'])) {
            mu = opt.other['mu'] ? opt.other['mu'] : mu;
            std = opt.other['std'] ? opt.other['std'] : std;
        }
        const firstLayer = 0;
        this.W1 = new _1.RandMat(opt.architecture['hiddenUnits'][firstLayer], opt.architecture['inputSize'], mu, std);
        this.b1 = new _1.Mat(opt.architecture['hiddenUnits'][firstLayer], 1);
        this.W2 = new _1.RandMat(opt.architecture['outputSize'], opt.architecture['hiddenUnits'][firstLayer], mu, std);
        this.b2 = new _1.Mat(opt.architecture['outputSize'], 1);
    }
    update(alpha) {
        this.W1.update(alpha);
        this.b1.update(alpha);
        this.W2.update(alpha);
        this.b2.update(alpha);
    }
    static toJSON(net) {
        const json = {};
        json['W1'] = _1.Mat.toJSON(net.W1);
        json['b1'] = _1.Mat.toJSON(net.b1);
        json['W2'] = _1.Mat.toJSON(net.W2);
        json['b2'] = _1.Mat.toJSON(net.b2);
        return json;
    }
    forward(state, graph) {
        const weightedInput = graph.mul(this.W1, state);
        const a1mat = graph.add(weightedInput, this.b1);
        const h1mat = graph.tanh(a1mat);
        const a2Mat = this.computeOutput(h1mat, graph);
        return a2Mat;
    }
    computeOutput(hiddenUnits, graph) {
        const weightedActivation = graph.mul(this.W2, hiddenUnits);
        const a2Mat = graph.add(weightedActivation, this.b2);
        return a2Mat;
    }
    static fromJSON(json) {
        return new Net(json);
    }
    static has(obj, keys) {
        for (const key of keys) {
            if (Object.hasOwnProperty.call(obj, key)) {
                continue;
            }
            return false;
        }
        return true;
    }
}
exports.Net = Net;
//# sourceMappingURL=net.js.map