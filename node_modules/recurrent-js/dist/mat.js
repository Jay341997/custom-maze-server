"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _1 = require(".");
const assertable_1 = require("./utils/assertable");
class Mat extends assertable_1.Assertable {
    constructor(rows, cols) {
        super();
        this.rows = rows;
        this.cols = cols;
        this._length = rows * cols;
        this.w = _1.Utils.zeros(this._length);
        this.dw = _1.Utils.zeros(this._length);
    }
    get(row, col) {
        const ix = this.getIndexBy(row, col);
        Mat.assert(ix >= 0 && ix < this.w.length, '[class:Mat] get: index out of bounds.');
        return this.w[ix];
    }
    set(row, col, v) {
        const ix = this.getIndexBy(row, col);
        Mat.assert(ix >= 0 && ix < this.w.length, '[class:Mat] set: index out of bounds.');
        this.w[ix] = v;
    }
    getIndexBy(row, col) {
        return (row * this.cols) + col;
    }
    setFrom(arr) {
        for (let i = 0; i < arr.length; i++) {
            this.w[i] = arr[i];
        }
    }
    setColumn(m, colIndex) {
        Mat.assert(m.w.length === this.rows, '[class:Mat] setColumn: dimensions misaligned.');
        for (let i = 0; i < m.w.length; i++) {
            this.w[(this.cols * i) + colIndex] = m.w[i];
        }
    }
    equals(m) {
        if (this.rows !== m.rows || this.cols !== m.cols) {
            return false;
        }
        for (let i = 0; i < this._length; i++) {
            if (this.w[i] !== m.w[i]) {
                return false;
            }
        }
        return true;
    }
    static toJSON(m) {
        const json = { rows: 0, cols: 0, w: [] };
        json.rows = m.rows || m.n;
        json.cols = m.cols || m.d;
        json.w = m.w;
        return json;
    }
    static fromJSON(json) {
        const rows = json.rows || json.n;
        const cols = json.cols || json.d;
        const mat = new Mat(rows, cols);
        for (let i = 0; i < mat._length; i++) {
            mat.w[i] = json.w[i];
        }
        return mat;
    }
    update(alpha) {
        for (let i = 0; i < this._length; i++) {
            if (this.dw[i] !== 0) {
                this.w[i] = this.w[i] - alpha * this.dw[i];
                this.dw[i] = 0;
            }
        }
    }
}
exports.Mat = Mat;
//# sourceMappingURL=mat.js.map