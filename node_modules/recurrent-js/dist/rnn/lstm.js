"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const __1 = require("./..");
const rnn_model_1 = require("./rnn-model");
class LSTM extends rnn_model_1.RNNModel {
    constructor(opt) {
        super(opt);
    }
    initializeNetworkModel() {
        return {
            hidden: {
                input: {
                    Wx: new Array(this.architecture.hiddenUnits.length),
                    Wh: new Array(this.architecture.hiddenUnits.length),
                    bh: new Array(this.architecture.hiddenUnits.length)
                },
                forget: {
                    Wx: new Array(this.architecture.hiddenUnits.length),
                    Wh: new Array(this.architecture.hiddenUnits.length),
                    bh: new Array(this.architecture.hiddenUnits.length)
                },
                output: {
                    Wx: new Array(this.architecture.hiddenUnits.length),
                    Wh: new Array(this.architecture.hiddenUnits.length),
                    bh: new Array(this.architecture.hiddenUnits.length)
                },
                cell: {
                    Wx: new Array(this.architecture.hiddenUnits.length),
                    Wh: new Array(this.architecture.hiddenUnits.length),
                    bh: new Array(this.architecture.hiddenUnits.length)
                },
            },
            decoder: {
                Wh: null,
                b: null
            }
        };
    }
    isFromJSON(opt) {
        return rnn_model_1.RNNModel.has(opt, ['hidden', 'decoder'])
            && rnn_model_1.RNNModel.has(opt.hidden, ['input', 'forget', 'output', 'cell'])
            && rnn_model_1.RNNModel.has(opt.input, ['Wh', 'Wx', 'bh'])
            && rnn_model_1.RNNModel.has(opt.forget, ['Wh', 'Wx', 'bh'])
            && rnn_model_1.RNNModel.has(opt.output, ['Wh', 'Wx', 'bh'])
            && rnn_model_1.RNNModel.has(opt.cell, ['Wh', 'Wx', 'bh'])
            && rnn_model_1.RNNModel.has(opt.decoder, ['Wh', 'b']);
    }
    initializeHiddenLayerFromJSON(opt) {
        rnn_model_1.RNNModel.assert(opt.hidden.forget && opt.hidden.forget && opt.hidden.output && opt.hidden.cell, 'Wrong JSON Format to recreat Hidden Layer.');
        this.isValid(opt.hidden.input);
        this.isValid(opt.hidden.forget);
        this.isValid(opt.hidden.output);
        this.isValid(opt.hidden.cell);
        for (let i = 0; i < opt.hidden.Wh.length; i++) {
            this.model.hidden.input.Wx = __1.Mat.fromJSON(opt.hidden.input.Wx);
            this.model.hidden.input.Wh = __1.Mat.fromJSON(opt.hidden.input.Wh);
            this.model.hidden.input.bh = __1.Mat.fromJSON(opt.hidden.input.bh);
            this.model.hidden.forget.Wx = __1.Mat.fromJSON(opt.hidden.Wx);
            this.model.hidden.forget.Wh = __1.Mat.fromJSON(opt.hidden.Wh);
            this.model.hidden.forget.bh = __1.Mat.fromJSON(opt.hidden.bh);
            this.model.hidden.output.Wx = __1.Mat.fromJSON(opt.hidden.Wx);
            this.model.hidden.output.Wh = __1.Mat.fromJSON(opt.hidden.Wh);
            this.model.hidden.output.bh = __1.Mat.fromJSON(opt.hidden.bh);
            this.model.hidden.cell.Wx = __1.Mat.fromJSON(opt.hidden.Wx);
            this.model.hidden.cell.Wh = __1.Mat.fromJSON(opt.hidden.Wh);
            this.model.hidden.cell.bh = __1.Mat.fromJSON(opt.hidden.hb);
        }
    }
    isValid(component) {
        rnn_model_1.RNNModel.assert(component && !Array.isArray(component['Wx']), 'Wrong JSON Format to recreat Hidden Layer.');
        rnn_model_1.RNNModel.assert(component && !Array.isArray(component['Wh']), 'Wrong JSON Format to recreat Hidden Layer.');
        rnn_model_1.RNNModel.assert(component && !Array.isArray(component['bh']), 'Wrong JSON Format to recreat Hidden Layer.');
    }
    initializeHiddenLayer() {
        for (let i = 0; i < this.architecture.hiddenUnits.length; i++) {
            const prevSize = i === 0 ? this.architecture.inputSize : this.architecture.hiddenUnits[i - 1];
            const hiddenSize = this.architecture.hiddenUnits[i];
            this.model.hidden.input.Wx[i] = new __1.RandMat(hiddenSize, prevSize, 0, 0.08);
            this.model.hidden.input.Wh[i] = new __1.RandMat(hiddenSize, hiddenSize, 0, 0.08);
            this.model.hidden.input.bh[i] = new __1.Mat(hiddenSize, 1);
            this.model.hidden.forget.Wx[i] = new __1.RandMat(hiddenSize, prevSize, 0, 0.08);
            this.model.hidden.forget.Wh[i] = new __1.RandMat(hiddenSize, hiddenSize, 0, 0.08);
            this.model.hidden.forget.bh[i] = new __1.Mat(hiddenSize, 1);
            this.model.hidden.output.Wx[i] = new __1.RandMat(hiddenSize, prevSize, 0, 0.08);
            this.model.hidden.output.Wh[i] = new __1.RandMat(hiddenSize, hiddenSize, 0, 0.08);
            this.model.hidden.output.bh[i] = new __1.Mat(hiddenSize, 1);
            this.model.hidden.cell.Wx[i] = new __1.RandMat(hiddenSize, prevSize, 0, 0.08);
            this.model.hidden.cell.Wh[i] = new __1.RandMat(hiddenSize, hiddenSize, 0, 0.08);
            this.model.hidden.cell.bh[i] = new __1.Mat(hiddenSize, 1);
        }
    }
    forward(input, previousActivationState, graph) {
        previousActivationState = previousActivationState ? previousActivationState : null;
        graph = graph ? graph : this.graph;
        const previousHiddenActivations = { cells: null, units: null };
        previousHiddenActivations.cells = this.getPreviousCellActivationsFrom(previousActivationState);
        previousHiddenActivations.units = this.getPreviousHiddenUnitActivationsFrom(previousActivationState);
        const hiddenActivations = this.computeHiddenActivations(input, previousHiddenActivations, graph);
        const output = this.computeOutput(hiddenActivations.units, graph);
        return { 'hiddenActivationState': hiddenActivations.units, 'cells': hiddenActivations.cells, 'output': output };
    }
    computeHiddenActivations(state, previousHiddenActivations, graph) {
        const hiddenActivations = { units: [], cells: [] };
        for (let i = 0; i < this.architecture.hiddenUnits.length; i++) {
            const inputVector = (i === 0) ? state : hiddenActivations.units[i - 1];
            const previousUnitActivations = previousHiddenActivations.units[i];
            const previousCellActivations = previousHiddenActivations.cells[i];
            const weightedStatelessInputPortion1 = graph.mul(this.model.hidden.input.Wx[i], inputVector);
            const weightedStatefulInputPortion1 = graph.mul(this.model.hidden.input.Wh[i], previousUnitActivations);
            const summedUpInput1 = graph.add(graph.add(weightedStatelessInputPortion1, weightedStatefulInputPortion1), this.model.hidden.input.bh[i]);
            const inputGateActivation = graph.sig(summedUpInput1);
            const weightedStatelessInputPortion2 = graph.mul(this.model.hidden.forget.Wx[i], inputVector);
            const weightedStatefulInputPortion2 = graph.mul(this.model.hidden.forget.Wh[i], previousUnitActivations);
            const summedUpInput2 = graph.add(graph.add(weightedStatelessInputPortion2, weightedStatefulInputPortion2), this.model.hidden.forget.bh[i]);
            const forgetGateActivation = graph.sig(summedUpInput2);
            const weightedStatelessInputPortion3 = graph.mul(this.model.hidden.output.Wx[i], inputVector);
            const weightedStatefulInputPortion3 = graph.mul(this.model.hidden.output.Wh[i], previousUnitActivations);
            const summedUpInput3 = graph.add(graph.add(weightedStatelessInputPortion3, weightedStatefulInputPortion3), this.model.hidden.output.bh[i]);
            const outputGateActivation = graph.sig(summedUpInput3);
            const weightedStatelessInputPortion4 = graph.mul(this.model.hidden.cell.Wx[i], inputVector);
            const weightedStatefulInputPortion4 = graph.mul(this.model.hidden.cell.Wh[i], previousUnitActivations);
            const summedUpInput4 = graph.add(graph.add(weightedStatelessInputPortion4, weightedStatefulInputPortion4), this.model.hidden.cell.bh[i]);
            const cellWriteActivation = graph.tanh(summedUpInput4);
            const retainCell = graph.eltmul(forgetGateActivation, previousCellActivations);
            const writeCell = graph.eltmul(inputGateActivation, cellWriteActivation);
            const cellActivations = graph.add(retainCell, writeCell);
            const activations = graph.eltmul(outputGateActivation, graph.tanh(cellActivations));
            hiddenActivations.cells.push(cellActivations);
            hiddenActivations.units.push(activations);
        }
        return hiddenActivations;
    }
    getPreviousCellActivationsFrom(previousActivationState) {
        let previousCellsActivations;
        if (this.givenPreviousActivationState(previousActivationState)) {
            previousCellsActivations = previousActivationState.cells;
        }
        else {
            previousCellsActivations = new Array();
            for (let i = 0; i < this.architecture.hiddenUnits.length; i++) {
                previousCellsActivations.push(new __1.Mat(this.architecture.hiddenUnits[i], 1));
            }
        }
        return previousCellsActivations;
    }
    getPreviousHiddenUnitActivationsFrom(previousActivationState) {
        let previousHiddenActivations;
        if (this.givenPreviousActivationState(previousActivationState)) {
            previousHiddenActivations = previousActivationState.hiddenActivationState;
        }
        else {
            previousHiddenActivations = new Array();
            for (let i = 0; i < this.architecture.hiddenUnits.length; i++) {
                previousHiddenActivations.push(new __1.Mat(this.architecture.hiddenUnits[i], 1));
            }
        }
        return previousHiddenActivations;
    }
    givenPreviousActivationState(previousInnerState) {
        return previousInnerState && typeof previousInnerState.hiddenActivationState !== 'undefined';
    }
    updateHiddenUnits(alpha) {
        for (let i = 0; i < this.architecture.hiddenUnits.length; i++) {
            this.model.hidden.input.Wx[i].update(alpha);
            this.model.hidden.input.Wh[i].update(alpha);
            this.model.hidden.input.bh[i].update(alpha);
            this.model.hidden.output.Wx[i].update(alpha);
            this.model.hidden.output.Wh[i].update(alpha);
            this.model.hidden.output.bh[i].update(alpha);
            this.model.hidden.forget.Wx[i].update(alpha);
            this.model.hidden.forget.Wh[i].update(alpha);
            this.model.hidden.forget.bh[i].update(alpha);
            this.model.hidden.cell.Wx[i].update(alpha);
            this.model.hidden.cell.Wh[i].update(alpha);
            this.model.hidden.cell.bh[i].update(alpha);
        }
    }
    updateDecoder(alpha) {
        this.model.decoder.Wh.update(alpha);
        this.model.decoder.b.update(alpha);
    }
}
exports.LSTM = LSTM;
//# sourceMappingURL=lstm.js.map