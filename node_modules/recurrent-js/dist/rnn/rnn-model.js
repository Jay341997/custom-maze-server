"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const __1 = require("./..");
const assertable_1 = require("./../utils/assertable");
class RNNModel extends assertable_1.Assertable {
    constructor(opt) {
        super();
        const needsBackpropagation = opt && opt.needsBackpropagation ? opt.needsBackpropagation : true;
        this.graph = new __1.Graph();
        this.graph.memorizeOperationSequence(true);
        if (this.isFromJSON(opt)) {
            this.initializeModelFromJSONObject(opt);
        }
        else if (this.isFreshInstanceCall(opt)) {
            this.initializeModelAsFreshInstance(opt);
        }
        else {
            RNNModel.assert(false, 'Improper input for DNN.');
        }
    }
    initializeModelFromJSONObject(opt) {
        this.initializeHiddenLayerFromJSON(opt);
        this.model.decoder.Wh = __1.Mat.fromJSON(opt['decoder']['Wh']);
        this.model.decoder.b = __1.Mat.fromJSON(opt['decoder']['b']);
    }
    isFreshInstanceCall(opt) {
        return RNNModel.has(opt, ['architecture']) && RNNModel.has(opt.architecture, ['inputSize', 'hiddenUnits', 'outputSize']);
    }
    initializeModelAsFreshInstance(opt) {
        this.architecture = opt.architecture;
        const mu = opt['mu'] ? opt['mu'] : 0;
        const std = opt['std'] ? opt['std'] : 0.01;
        this.model = this.initializeNetworkModel();
        this.initializeHiddenLayer(mu, std);
        this.initializeDecoder(mu, std);
    }
    initializeDecoder(mu, std) {
        this.model.decoder.Wh = new __1.RandMat(this.architecture.outputSize, this.architecture.hiddenUnits[this.architecture.hiddenUnits.length - 1], mu, std);
        this.model.decoder.b = new __1.Mat(this.architecture.outputSize, 1);
    }
    update(alpha) {
        this.updateHiddenUnits(alpha);
        this.updateDecoder(alpha);
    }
    computeOutput(hiddenActivations, graph) {
        const precedingHiddenLayerActivations = hiddenActivations[hiddenActivations.length - 1];
        const weightedInputs = graph.mul(this.model.decoder.Wh, precedingHiddenLayerActivations);
        return graph.add(weightedInputs, this.model.decoder.b);
    }
    static has(obj, keys) {
        RNNModel.assert(obj, '[class:rnn-model] improper input for instantiation');
        for (const key of keys) {
            if (Object.hasOwnProperty.call(obj, key)) {
                continue;
            }
            return false;
        }
        return true;
    }
}
exports.RNNModel = RNNModel;
//# sourceMappingURL=rnn-model.js.map