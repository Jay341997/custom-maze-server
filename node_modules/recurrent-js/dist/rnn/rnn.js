"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const __1 = require("./..");
const rnn_model_1 = require("./rnn-model");
class RNN extends rnn_model_1.RNNModel {
    constructor(opt) {
        super(opt);
    }
    isFromJSON(opt) {
        return rnn_model_1.RNNModel.has(opt, ['hidden', 'decoder'])
            && rnn_model_1.RNNModel.has(opt.hidden, ['Wh', 'Wx', 'bh'])
            && rnn_model_1.RNNModel.has(opt.decoder, ['Wh', 'b']);
    }
    initializeHiddenLayerFromJSON(opt) {
        rnn_model_1.RNNModel.assert(!Array.isArray(opt['hidden']['Wh']), 'Wrong JSON Format to recreate Hidden Layer.');
        rnn_model_1.RNNModel.assert(!Array.isArray(opt['hidden']['Wx']), 'Wrong JSON Format to recreate Hidden Layer.');
        rnn_model_1.RNNModel.assert(!Array.isArray(opt['hidden']['bh']), 'Wrong JSON Format to recreate Hidden Layer.');
        for (let i = 0; i < opt.hidden.Wh.length; i++) {
            this.model.hidden.Wx[i] = __1.Mat.fromJSON(opt.hidden.Wx[i]);
            this.model.hidden.Wh[i] = __1.Mat.fromJSON(opt.hidden.Wh[i]);
            this.model.hidden.bh[i] = __1.Mat.fromJSON(opt.hidden.bh[i]);
        }
    }
    initializeNetworkModel() {
        return {
            hidden: {
                Wx: new Array(this.architecture.hiddenUnits.length),
                Wh: new Array(this.architecture.hiddenUnits.length),
                bh: new Array(this.architecture.hiddenUnits.length)
            },
            decoder: {
                Wh: null,
                b: null
            }
        };
    }
    initializeHiddenLayer() {
        let hiddenSize;
        for (let i = 0; i < this.architecture.hiddenUnits.length; i++) {
            const previousSize = i === 0 ? this.architecture.inputSize : this.architecture.hiddenUnits[i - 1];
            hiddenSize = this.architecture.hiddenUnits[i];
            this.model.hidden.Wx[i] = new __1.RandMat(hiddenSize, previousSize, 0, 0.08);
            this.model.hidden.Wh[i] = new __1.RandMat(hiddenSize, hiddenSize, 0, 0.08);
            this.model.hidden.bh[i] = new __1.Mat(hiddenSize, 1);
        }
    }
    forward(input, previousActivationState, graph) {
        previousActivationState = previousActivationState ? previousActivationState : null;
        graph = graph ? graph : this.graph;
        const previousHiddenActivations = this.getPreviousHiddenActivationsFrom(previousActivationState);
        const hiddenActivations = this.computeHiddenActivations(input, previousHiddenActivations, graph);
        const output = this.computeOutput(hiddenActivations, graph);
        return { 'hiddenActivationState': hiddenActivations, 'output': output };
    }
    getPreviousHiddenActivationsFrom(previousActivationState) {
        let previousHiddenActivations;
        if (this.givenPreviousActivationState(previousActivationState)) {
            previousHiddenActivations = previousActivationState.hiddenActivationState;
        }
        else {
            previousHiddenActivations = new Array();
            for (let i = 0; i < this.architecture.hiddenUnits.length; i++) {
                previousHiddenActivations.push(new __1.Mat(this.architecture.hiddenUnits[i], 1));
            }
        }
        return previousHiddenActivations;
    }
    givenPreviousActivationState(previousActivationState) {
        return previousActivationState && typeof previousActivationState.hiddenActivationState !== 'undefined';
    }
    computeHiddenActivations(input, previousHiddenActivations, graph) {
        const hiddenActivations = new Array();
        for (let i = 0; i < this.architecture.hiddenUnits.length; i++) {
            const inputVector = i === 0 ? input : hiddenActivations[i - 1];
            const previousActivations = previousHiddenActivations[i];
            const weightedStatelessInputPortion = graph.mul(this.model.hidden.Wx[i], inputVector);
            const weightedStatefulInputPortion = graph.mul(this.model.hidden.Wh[i], previousActivations);
            const activation = graph.relu(graph.add(graph.add(weightedStatelessInputPortion, weightedStatefulInputPortion), this.model.hidden.bh[i]));
            hiddenActivations.push(activation);
        }
        return hiddenActivations;
    }
    updateHiddenUnits(alpha) {
        for (let i = 0; i < this.architecture.hiddenUnits.length; i++) {
            this.model.hidden.Wx[i].update(alpha);
            this.model.hidden.Wh[i].update(alpha);
            this.model.hidden.bh[i].update(alpha);
        }
    }
    updateDecoder(alpha) {
        this.model.decoder.Wh.update(alpha);
        this.model.decoder.b.update(alpha);
    }
}
exports.RNN = RNN;
//# sourceMappingURL=rnn.js.map