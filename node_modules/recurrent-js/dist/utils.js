"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class Utils {
    static randf(min, max) {
        return Math.random() * (max - min) + min;
    }
    static randi(min, max) {
        return Math.floor(Utils.randf(min, max));
    }
    static randn(mu, std) {
        return mu + Utils.gaussRandom() * std;
    }
    static skewedRandn(mu, std, skew) {
        let sample = Utils.box_muller();
        sample = Math.pow(sample, skew);
        sample = (sample - 0.5) * 10;
        return mu + sample * std;
    }
    static gaussRandom() {
        return (Utils.box_muller() - 0.5) * 10;
    }
    static box_muller() {
        let z0 = 0, u1 = 0, u2 = 0;
        do {
            u1 = u2 = 0;
            do {
                u1 = Math.random();
            } while (u1 === 0);
            do {
                u2 = Math.random();
            } while (u2 === 0);
            z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
            z0 = z0 / 10.0 + 0.5;
        } while (z0 > 1 || z0 < 0);
        return z0;
    }
    static sum(arr) {
        let sum = 0;
        for (let i = 0; i < arr.length; i++) {
            sum += arr[i];
        }
        return sum;
    }
    static mean(arr) {
        const count = arr.length;
        const sum = Utils.sum(arr);
        return sum / count;
    }
    static median(arr) {
        let median = 0;
        const count = arr.length;
        arr.sort();
        if (count % 2 === 0) {
            median = (arr[count / 2 - 1] + arr[count / 2]) / 2;
        }
        else {
            median = arr[(count - 1) / 2];
        }
        return median;
    }
    static mode(arr, precision) {
        precision = precision ? precision : 1e6;
        const modes = [];
        const count = [];
        let num = 0;
        let maxCount = 0;
        for (let i = 0; i < arr.length; i++) {
            num = Math.round(arr[i] * precision) / precision;
            count[num] = (count[num] || 0) + 1;
            if (count[num] > maxCount) {
                maxCount = count[num];
            }
        }
        for (const i in count) {
            if (count.hasOwnProperty(i)) {
                if (count[i] === maxCount) {
                    modes.push(Number(i));
                }
            }
        }
        return modes;
    }
    static var(arr, normalization) {
        normalization = normalization ? normalization : 'unbiased';
        const count = arr.length;
        const mean = Utils.mean(arr);
        let sum = 0;
        let diff = 0;
        for (let i = 0; i < arr.length; i++) {
            diff = arr[i] - mean;
            sum += diff * diff;
        }
        switch (normalization) {
            case 'uncorrected':
                return sum / count;
            case 'biased':
                return sum / (count + 1);
            case 'unbiased':
                return (count === 1) ? 0 : sum / (count - 1);
            default:
                return;
        }
    }
    static fillRandn(arr, mu, std) {
        for (let i = 0; i < arr.length; i++) {
            arr[i] = Utils.randn(mu, std);
        }
    }
    static fillRand(arr, min, max) {
        for (let i = 0; i < arr.length; i++) {
            arr[i] = Utils.randf(min, max);
        }
    }
    static fillConst(arr, c) {
        for (let i = 0; i < arr.length; i++) {
            arr[i] = c;
        }
    }
    static ones(n) {
        return Utils.fillArray(n, 1);
    }
    static zeros(n) {
        return Utils.fillArray(n, 0);
    }
    static fillArray(n, val) {
        if (typeof n === 'undefined' || isNaN(n)) {
            return [];
        }
        if (typeof ArrayBuffer === 'undefined') {
            const arr = new Array(n);
            Utils.fillConst(arr, val);
            return arr;
        }
        else {
            const arr = new Float64Array(n);
            Utils.fillConst(arr, val);
            return arr;
        }
    }
    static argmax(arr) {
        let maxValue = arr[0];
        let maxIndex = 0;
        for (let i = 1; i < arr.length; i++) {
            const v = arr[i];
            if (v > maxValue) {
                maxIndex = i;
                maxValue = v;
            }
        }
        return maxIndex;
    }
    static sampleWeighted(arr) {
        const r = Math.random();
        let c = 0.0;
        for (let i = 0; i < arr.length; i++) {
            c += arr[i];
            if (c >= r) {
                return i;
            }
        }
        return 0;
    }
}
Utils.std = (arr, normalization) => {
    return Math.sqrt(Utils.var(arr, normalization));
};
exports.Utils = Utils;
//# sourceMappingURL=utils.js.map