"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const recurrent_js_1 = require("recurrent-js");
const _1 = require("./../.");
class TDSolver extends _1.Solver {
    constructor(env, opt) {
        super(env, opt);
        this.env = env;
        this.alpha = opt.get('alpha');
        this.epsilon = opt.get('epsilon');
        this.gamma = opt.get('gamma');
        this.update = opt.get('update');
        this.updateSmoothPolicy = opt.get('smoothPolicyUpdate');
        this.beta = opt.get('beta');
        this.lambda = opt.get('lambda');
        this.replacingTraces = opt.get('replacingTraces');
        this.qInitValue = opt.get('qInitVal');
        this.numberOfPlanningSteps = opt.get('numberOfPlanningSteps');
        this.Q = null;
        this.randomPolicies = null;
        this.eligibilityTraces = null;
        this.envModelS = null;
        ;
        this.envModelR = null;
        ;
        this.env = env;
        this.reset();
    }
    reset() {
        this.numberOfStates = this.env.get('numberOfStates');
        this.numberOfActions = this.env.get('numerOfActions');
        this.Q = recurrent_js_1.Utils.zeros(this.numberOfStates * this.numberOfActions);
        if (this.qInitValue !== 0) {
            recurrent_js_1.Utils.fillConst(this.Q, this.qInitValue);
        }
        this.randomPolicies = recurrent_js_1.Utils.zeros(this.numberOfStates * this.numberOfActions);
        this.eligibilityTraces = recurrent_js_1.Utils.zeros(this.numberOfStates * this.numberOfActions);
        this.envModelS = recurrent_js_1.Utils.zeros(this.numberOfStates * this.numberOfActions);
        recurrent_js_1.Utils.fillConst(this.envModelS, -1);
        this.envModelR = recurrent_js_1.Utils.zeros(this.numberOfStates * this.numberOfActions);
        this.saSeen = [];
        this.pq = recurrent_js_1.Utils.zeros(this.numberOfStates * this.numberOfActions);
        for (let state = 0; state < this.numberOfStates; state++) {
            const allowedActions = this.env.allowedActions(state);
            for (let i = 0; i < allowedActions.length; i++) {
                this.randomPolicies[allowedActions[i] * this.numberOfStates + state] = 1.0 / allowedActions.length;
            }
        }
        this.r0 = null;
        this.s0 = null;
        this.s1 = null;
        this.a0 = null;
        this.a1 = null;
    }
    decide(state) {
        const allowedActions = this.env.allowedActions(state);
        const probs = new Array();
        for (let i = 0; i < allowedActions.length; i++) {
            probs.push(this.randomPolicies[allowedActions[i] * this.numberOfStates + state]);
        }
        const actionIndex = this.epsilonGreedyActionPolicy(allowedActions, probs);
        this.shiftStateMemory(state, actionIndex);
        return actionIndex;
    }
    shiftStateMemory(state, actionIndex) {
        this.s0 = this.s1;
        this.a0 = this.a1;
        this.s1 = state;
        this.a1 = actionIndex;
    }
    epsilonGreedyActionPolicy(poss, probs) {
        let actionIndex = 0;
        if (Math.random() < this.epsilon) {
            actionIndex = poss[recurrent_js_1.Utils.randi(0, poss.length)];
            this.explored = true;
        }
        else {
            actionIndex = poss[recurrent_js_1.Utils.sampleWeighted(probs)];
            this.explored = false;
        }
        return actionIndex;
    }
    learn(r1) {
        if (!(this.r0 == null)) {
            this.learnFromTuple(this.s0, this.a0, this.r0, this.s1, this.a1, this.lambda);
            if (this.numberOfPlanningSteps > 0) {
                this.updateModel(this.s0, this.a0, this.r0, this.s1);
                this.plan();
            }
        }
        this.r0 = r1;
    }
    learnFromTuple(s0, a0, r0, s1, a1, lambda) {
        const sa = a0 * this.numberOfStates + s0;
        let target;
        if (this.update === 'qlearn') {
            const poss = this.env.allowedActions(s1);
            let qmax = 0;
            for (let i = 0; i < poss.length; i++) {
                const s1a = poss[i] * this.numberOfStates + s1;
                const qval = this.Q[s1a];
                if (i === 0 || qval > qmax) {
                    qmax = qval;
                }
            }
            target = r0 + this.gamma * qmax;
        }
        else if (this.update === 'sarsa') {
            const s1a1 = a1 * this.numberOfStates + s1;
            target = r0 + this.gamma * this.Q[s1a1];
        }
        if (lambda > 0) {
            if (null) {
                this.eligibilityTraces[sa] = 1;
            }
            else {
                this.eligibilityTraces[sa] += 1;
            }
            const decay = lambda * this.gamma;
            const stateUpdate = recurrent_js_1.Utils.zeros(this.numberOfStates);
            for (let s = 0; s < this.numberOfStates; s++) {
                const poss = this.env.allowedActions(s);
                for (let i = 0; i < poss.length; i++) {
                    const a = poss[i];
                    const saloop = a * this.numberOfStates + s;
                    const esa = this.eligibilityTraces[saloop];
                    const update = this.alpha * esa * (target - this.Q[saloop]);
                    this.Q[saloop] += update;
                    this.updatePriority(s, a, update);
                    this.eligibilityTraces[saloop] *= decay;
                    const u = Math.abs(update);
                    if (u > stateUpdate[s]) {
                        stateUpdate[s] = u;
                    }
                }
            }
            for (let s = 0; s < this.numberOfStates; s++) {
                if (stateUpdate[s] > 1e-5) {
                    this.updatePolicy(s);
                }
            }
            if (this.explored && this.update === 'qlearn') {
                this.eligibilityTraces = recurrent_js_1.Utils.zeros(this.numberOfStates * this.numberOfActions);
            }
        }
        else {
            const update = this.alpha * (target - this.Q[sa]);
            this.Q[sa] += update;
            this.updatePriority(s0, a0, update);
            this.updatePolicy(s0);
        }
    }
    updateModel(s0, a0, r0, s1) {
        const sa = a0 * this.numberOfStates + s0;
        if (this.envModelS[sa] === -1) {
            this.saSeen.push(a0 * this.numberOfStates + s0);
        }
        this.envModelS[sa] = s1;
        this.envModelR[sa] = r0;
    }
    plan() {
        const spq = [];
        for (let i = 0; i < this.saSeen.length; i++) {
            const sa = this.saSeen[i];
            const sap = this.pq[sa];
            if (sap > 1e-5) {
                spq.push({ 'sa': sa, 'p': sap });
            }
        }
        spq.sort((a, b) => { return a.p < b.p ? 1 : -1; });
        const nsteps = Math.min(this.numberOfPlanningSteps, spq.length);
        for (let k = 0; k < nsteps; k++) {
            const s0a0 = spq[k].sa;
            this.pq[s0a0] = 0;
            const s0 = s0a0 % this.numberOfStates;
            const a0 = Math.floor(s0a0 / this.numberOfStates);
            const r0 = this.envModelR[s0a0];
            const s1 = this.envModelS[s0a0];
            const a1 = -1;
            if (this.update === 'sarsa') {
                const poss = this.env.allowedActions(s1);
                const a1 = poss[recurrent_js_1.Utils.randi(0, poss.length)];
            }
            this.learnFromTuple(s0, a0, r0, s1, a1, 0);
        }
    }
    updatePriority(s, a, u) {
        u = Math.abs(u);
        if (u < 1e-5) {
            return;
        }
        if (this.numberOfPlanningSteps === 0) {
            return;
        }
        for (let si = 0; si < this.numberOfStates; si++) {
            for (let ai = 0; ai < this.numberOfActions; ai++) {
                const siai = ai * this.numberOfStates + si;
                if (this.envModelS[siai] === s) {
                    this.pq[siai] += u;
                }
            }
        }
    }
    updatePolicy(s) {
        const poss = this.env.allowedActions(s);
        let qmax, nmax;
        const qs = [];
        for (let i = 0; i < poss.length; i++) {
            const a = poss[i];
            const qval = this.Q[a * this.numberOfStates + s];
            qs.push(qval);
            if (i === 0 || qval > qmax) {
                qmax = qval;
                nmax = 1;
            }
            else if (qval === qmax) {
                nmax += 1;
            }
        }
        let psum = 0.0;
        for (let i = 0; i < poss.length; i++) {
            const a = poss[i];
            const target = (qs[i] === qmax) ? 1.0 / nmax : 0.0;
            const ix = a * this.numberOfStates + s;
            if (this.updateSmoothPolicy) {
                this.randomPolicies[ix] += this.beta * (target - this.randomPolicies[ix]);
                psum += this.randomPolicies[ix];
            }
            else {
                this.randomPolicies[ix] = target;
            }
        }
        if (this.updateSmoothPolicy) {
            for (let i = 0; i < poss.length; i++) {
                const a = poss[i];
                this.randomPolicies[a * this.numberOfStates + s] /= psum;
            }
        }
    }
    toJSON() {
        throw new Error('Not implemented yet.');
    }
    fromJSON(json) {
        throw new Error('Not implemented yet.');
    }
}
exports.TDSolver = TDSolver;
//# sourceMappingURL=td-solver.js.map